# Name: audit_file_email.pl
# Version: 1.0 
# Released: 2015-04-16 
# Description: A Perl script that processes the previous day's EZProxy audit log and  
#			   generates an email with interesting information.
#
# Software Requirements: Blat, Perl (Tested with Perl v5.8.8), and Windows OS. (This script 
# was written, tested, and is deployed in a Windows server environment. It may work with 
# other OS with some tweaks, but I cannot offer any guarantees.) 
#						 
#
# Inputs: 
#	- previous day's EZProxy audit log from EZProxy server. Format example: 20141028.txt
#	- Geographic location files GeoLiteCity-Location.csv and GeoLiteCity-Blocks.csv located at:
#	  http://geolite.maxmind.com/download/geoip/database/GeoLiteCity_CSV/GeoLiteCity-latest.zip. 
#	  Unzip the file and place the CSV files in the same directory as the GeoLiteCity.dat file
#	  that is used with EZProxy.
#	  This file should be updated monthly when you update the GeoLiteCity.dat file. 
#	- user_watchlist.txt - A locally maintained text file that contains usernames for the script to look 
#	  for and report on. One username per line, comments and blank lines are allowed in the file.
#	- ip_watchlist.txt - A locally maintained text file that contains IP addresses for the script to look 
#	  for and report on. One IP address per line, comments and blank lines are allowed in the file.
#		
# Outputs: A text file, audit_log_email.txt, that has collected interesting information from the 
# audit log, that will then be emailed to whomever you wish using Blat.
#
# NOTE: In order for this script to run, 12 variables with the value "CHANGE_ME" must be updated to match your local 
#		environment. This mostly has to do with path names and access to files, but also local variables. 
#		Examples are provided. Search this script to locate locate them all. 
#
# Written by Paul Butler, Ball State University Libraries, prbutler@bsu.edu. Caveat emptor!


use strict;
use POSIX qw(strftime);  ###Used to identify the current date to define the audit file to grab and process. 
use Socket; ###Used for IP conversions in the ip_to_int subroutine. 
### use Data::Dumper; ###Used for printing and testing hashes. 

###################################################################
### File Input and Output Setup ###################################
###################################################################

### Email address(es) the audit file email is sent to when the script is complete. 
### You must use the backslash \ to escape the @ sign in the address.
### Multiple address are permitted, separated by a comma.  
### Example: my $emailAddresses = "prbutler\@bsu.edu";
### Example with two email addresses: my $emailAddresses = "prbutler\@bsu.edu, prbutler\@bsu.edu";
my $emailAddresses = "CHANGE_ME";

### This variable holds the directory location of blat and the name for the blat exe. 
### Example: my $blatLocation = "C:/Program Files/blat/blat";
my $blatLocation = "CHANGE_ME";

### This variable holds the directory location of the audit log email that is generated by this script, 
### and the file name. 
### Example: my $emailTextLocation = "C:/ezproxy/audit_log_email.txt";
my $emailTextLocation = "CHANGE_ME";

###################################################################
### Input for EZProxy audit log file ##############################

### This section creates the file name for the previous day's audit log file. 
my $day_before = time() - 86400;
my @yesterday = localtime $day_before;
my $yyyymmdd = strftime("%Y%m%d", @yesterday);
my $yesterdays_audit_file = $yyyymmdd.".txt";

### To test a specific audit file on the EZProxy server instead of the previous day's audit file, uncomment the line 
### below and update the value to the file you wish the script to process. 
### $yesterdays_audit_file = "20111111.txt";

### This variable holds the location of the directory that contains the audit logs. Note the need to 
### escape slashes and $ in the directory path with backslash \. If this Perl script is in the EZProxy directory, and  
### the audit files are in the audit directory, the value should be as shown in the example below. 
### Example: my $audit_log_directory = "\\audit";
my $audit_log_directory = "CHANGE_ME";

### This variable stores the directory path and file name for the audit file. 
my $audit_log_location = $audit_log_directory."\\".$yesterdays_audit_file;

open (DATA, "$audit_log_location") or die "Can't open $audit_log_location for read: $!";

### @audit_log is the array that holds the rows of the EZProxy audit log. 
my @audit_log = <DATA>;
close DATA or die "Cannot close $audit_log_location: $!";

### This shift removes the first row of the audit log, which is the column headers. Chomp cleans up end of line. 
shift @audit_log;
chomp @audit_log;

###################################################################
### Input for the EZProxy user_watchlist.txt ######################

### This variable holds the directory path and file name for a text file that contains the names of users that 
### we wish to monitor and report on. In the example, the file user_watchlist.txt is in the EZProxy directory.
### A backslash \ is used to escape directory path slashes. 
### Example: my $watchlist = "\\ezproxy\\user_watchlist.txt";
my $watchlist = "CHANGE_ME";

open (WATCH, "$watchlist") or die "Can't open $watchlist for read: $!";

### This array holds the usernames on the EZPorxy watchlist. 
chomp(my @watchlist_array = <WATCH>);
close WATCH or die "Cannot close $watchlist: $!"; 

###################################################################
### Input for the EZProxy ip_watchlist.txt ########################

### This variable holds the directory path and file name for a text file that contains IP addresses  
### to keep an eye on. A backslash \ is used to escape directory path slashes. 
### Example: my $IPwatchlist = "\\ezproxy\\ip_watchlist.txt";
my $IPwatchlist = "CHANGE_ME";

open (WATCH, "$IPwatchlist") or die "Can't open $IPwatchlist for read: $!";

### This array holds the IP addresses on the IP watchlist. 
chomp(my @IP_watchlist_array = <WATCH>);
close WATCH or die "Cannot close $IPwatchlist: $!"; 

###################################################################
### Inputs for geoloc look ups. ###################################

### Below a number of arrays are declared that store all the geoloc information.
### These need to be declared globally because they are used throughout the script. 
my (@covertedIPLower, @covertedIPUpper, @locId, @cityLocId, @country, @region, @city);

### A variable the holds the directory path and file name for the GeoLiteCity-Blocks file.
### A backslash \ is used to escape directory path slashes. 
### The example below assumes the file GeoLiteCity-Blocks.csv is located in the main EZProxy directory. 
### Example: my $geoLocBlocks = "\\ezproxy\\GeoLiteCity-Blocks.csv";
my $geoLocBlocks = "CHANGE_ME";

### Opens the GeoLiteCity-Blocks.csv file, grabs the starting converted IP address of the IP range
### (@covertedIPLower), the ending converted IP address in the range (@covertedIPLower), and the locId 
### (@locId) from each line, and puts these elements into their corresponding arrays. The first two lines of 
### the file are junk. 
open my $GEOLOC, '<', $geoLocBlocks or die "Cannot open: $!";

while (<$GEOLOC>){
	chomp;
	
	### The values are separated by commas and the values are surrounded by quotation marks, splitting
	###	this way removes some of the junk for us. 
    my @line=split(/","/);
	
	### Temp variable used because the values in the source file have double quotation marks 
	### around them that need to be removed using substr. 
	my $tempCovertedIPLower = substr(@line[0], 1);
	push (@covertedIPLower, $tempCovertedIPLower);
	
	### No temp variable needed, as the line split removes the quotation marks. 
	push (@covertedIPUpper, @line[1]);
	
	### Temp variable used because the values in the source file have double quotation marks 
	### around them that need to be removed using substr. 
	my $tempLocId = substr(@line[2], 0, -1);
	push (@locId, $tempLocId);
}
close $GEOLOC;

### A variable the holds the directory path and file name for the GeoLiteCity-Location.csv file.
### A backslash \ is used to escape directory path slashes. 
### The example below assumes the file GeoLiteCity-Location.csv is located in the main ezproxy directory. 
### Example: my $geoLocCities = "\\ezproxy\\GeoLiteCity-Location.csv";
my $geoLocCities = "CHANGE_ME";

### Opens the GeoLiteCity-Location.csv file, grabs the first four elements in the row
### (locId,country,region,city), and puts these elements into their corresponding arrays. 
### The first two lines of the file are junk. 
open my $CITYLOC, '<', $geoLocCities or die "Cannot open: $!";

while (<$CITYLOC>){
	chomp;
    my @nline=split(/,/);
	
	push (@cityLocId, @nline[0]);
	
	### Temp variable used because the values in the source file have double quotation marks 
	### around them that need to be removed using substr. 
	my $tempCountry = substr(@nline[1], 1);
	$tempCountry = substr($tempCountry, 0, -1);
	push (@country, $tempCountry);

	### Temp variable used because the values in the source file have double quotation marks 
	### around them that need to be removed using substr. 
	my $tempRegion = substr(@nline[2], 1);
	$tempRegion = substr($tempRegion, 0, -1);
	push (@region, $tempRegion);
	
	### Temp variable used because the values in the source file have double quotation marks 
	### around them that need to be removed using substr. 
	my $tempCity = substr(@nline[3], 1);
	$tempCity = substr($tempCity, 0, -1);
	push (@city, $tempCity);
}
close $CITYLOC;

###################################################################
### Opens a file handler for the output file. #####################

### This variable holds the directory path and file name for a text file that contains the output 
### for the script, AKA the content of the email. In the example below, the file is called 
### audit_log_email.txt and it will be located in the same directory as the Perl script 
### that generated it.
### Example: my $outfile = "audit_log_email.txt";
my $outfile = "CHANGE_ME";

open(OUT, "> $outfile");

###################################################################
### Audit Log Processing ##########################################
###################################################################

### Globally declared arrays to hold various events identified for a number of reasons. 
my @deniedUsers = "\n___Denied Users___";
my @systemEvents = "\n___EZProxy System Events___";
my @ipIntruders = "\n___Login.Intruder.IP Events___";
my @userIntruders = "\n___Login.Intruder.User Events___";
my @rejectedIPs = "\n___Rejected IP Addresses___";
my @usageLimitEvents = "\n___UsageLimit Events___";
my @reportUser = "\n___Expired Users___";
my @successfulUsersEvents = "";

### This hash is used with the subroutine locID_look_up to store IP addresses that have already 
### been looked up, to save processing time.
### This is a tempDecimalIP -> location information hash that is used to hold lookups that previously 
### occurred. This speeds up the locID_look_up subroutine, and the script, particularly when you 
### are dealing with a audit log with numerous events, such as during a coordinated attack.  
my %previousLookupHash = (); 

### This hash is used with the subroutine city_look_up to store geographic location information
### that has already been looked up, to save processing time. 
my %previousLocIDHash = (); 

### The variable below is used to identified rejected IP Addresses. We use this method to reject 
### IP addresses: https://pluto.potsdam.edu/ezproxywiki/index.php/Restricted_IP_Logging_and_Response
### The matching value "IP_Address_Blocked" should be the message for these 
### events you selected to be displayed in the Other field in the EZProxy audit log
### when an IP address is blocked. As it is now, even if you do not use this technique
###	to block IP addresses having this elsif-statement in the script will not 
### adversely affect anything, but just add additional text to the output email.
### It could easily be modified to meet local needs. 
### Example: my $blockMessage = "IP_Address_Blocked";
my $blockMessage = "CHANGE_ME";

### Foreach-loop that goes thru each row of the EZProxy audit log array. Where much of the work is done. 
foreach (@audit_log) {

	if ($_ =~ /Login.Success/) {
		### Identify Expired Users Who Login Successfully ############
		### This if-statement is used to identity and report users with expired library privileges 
		### according to a lookup in our ILS that have successfully logged into EZProxy. 
		### It can be adapted/extend by other sites to lookup and report whatever the site wishes.
		### A site can replace/remove this entire if-statement and the cosponsoring code to write 
		### the array to the output file without effecting the script. The elsif-statement
		### below would have to become an if-statement. 

		### Example: my $reportUser = "Expired User";
		my $reportUser = "CHANGE_ME";
		
		my @logEvent = split('\t',$_);
		my $ipAddress = @logEvent[2];
		my $decIP = ip_to_int($ipAddress);
		my $locationInfo = locID_look_up($decIP);
	
		### Calls subroutine to lookup user in ILS, in this case to identify users with expired library privileges.  
		my $userILSInfo = ILS_lookup($_);		
				
		### If the subroutine passes the userILSInfo as expired, add the event and the user's 
		### status to the reportUser array. 
		if ($userILSInfo =~ /$reportUser/) {
			push @reportUser, "$locationInfo | @logEvent[0,1,2,3,5] $userILSInfo";
		}
	}	
	elsif ($_ =~ /Login.Denied/) {		
		### Identifies Denied Users ###################################
		
		my @logEvent = split('\t',$_);
		my $ipAddress = @logEvent[2];
		my $decIP = ip_to_int($ipAddress);
		my $locationInfo = locID_look_up($decIP);
	
		### Calls subroutine to lookup user in ILS, in this case to identify users with expired library privileges.  
		my $userILSInfo = ILS_lookup($_);
		
		push @deniedUsers, "$locationInfo | $_ $userILSInfo";
	}
	elsif ($_ =~ /$blockMessage/) {
		### Identifies rejected IP Addresses ##########################	
		### This elsif-statement is used to identify blocked IP addresses using this method:
		### https://pluto.potsdam.edu/ezproxywiki/index.php/Restricted_IP_Logging_and_Response
		### The matching value "IP_Address_Blocked", declared above the foreach loop as $blockMessage,  
		### should be the message for these events you selected to be displayed in the Other field 
		### in the EZProxy audit log when an IP address is blocked. As it is now, even if you do not 
		###	use this technique to block IP addresses having this elsif-statement in the script will not 
		### adversely affect anything, but just add additional text to the output email.
		
		my @logEvent = split('\t',$_);
		my $ipAddress = @logEvent[2];
		my $decIP = ip_to_int($ipAddress);
		my $locationInfo = locID_look_up($decIP);
	
		### Calls subroutine to lookup user in ILS, in this case to identify users with expired library privileges.  
		my $userILSInfo = ILS_lookup($_);		
		
		push @rejectedIPs, "$locationInfo | $_ $userILSInfo";
	}
	elsif ($_ =~ /Login.Intruder.IP/) {			
		### Identifies Login.Intruder.IP Events #######################	
		
		my @logEvent = split('\t',$_);
		my $ipAddress = @logEvent[2];
		my $decIP = ip_to_int($ipAddress);
		my $locationInfo = locID_look_up($decIP);
	
		### Calls subroutine to lookup user in ILS, in this case to identify users with expired library privileges.  
		my $userILSInfo = ILS_lookup($_);		
		
		push @ipIntruders, "$locationInfo | $_ $userILSInfo";
	}
	elsif ($_ =~ /5 failed login attempts/){	
		### Identifies Login.Intruder.User Events #####################	
		
		my @logEvent = split('\t',$_);
		my $ipAddress = @logEvent[2];
		my $decIP = ip_to_int($ipAddress);
		my $locationInfo = locID_look_up($decIP);
	
		### Calls subroutine to lookup user in ILS, in this case to identify users with expired library privileges.  
		my $userILSInfo = ILS_lookup($_);		
		
		push @userIntruders, "$locationInfo | $_ $userILSInfo";
	}
	elsif ($_ =~ /UsageLimit/){	
		### Identifies UsageLimit Events #####################	
		
		my @logEvent = split('\t',$_);
		my $ipAddress = @logEvent[2];
		my $decIP = ip_to_int($ipAddress);
		my $locationInfo = locID_look_up($decIP);
	
		### Calls subroutine to lookup user in ILS, in this case to identify users with expired library privileges.  
		my $userILSInfo = ILS_lookup($_);		
		
		push @usageLimitEvents, "$locationInfo | $_ $userILSInfo";
	}
	elsif (($_ =~ /\//) && ($_ !~ /^Date/)) {
		### Identifies System Events ##################################
		### Such as /logout. 
		
		my @logEvent = split('\t',$_);
		my $ipAddress = @logEvent[2];
		my $decIP = ip_to_int($ipAddress);
		my $locationInfo = locID_look_up($decIP);
	
		### Calls subroutine to lookup user in ILS, in this case to identify users with expired library privileges.  
		my $userILSInfo = ILS_lookup($_);		
		
		if ($ipAddress == ""){
			my $locationInfo = "No IP Address";
			push @systemEvents, "$locationInfo | $_ $userILSInfo";
		}
		else {
			my $decIP = ip_to_int($ipAddress);
			my $locationInfo = locID_look_up($decIP);
			push @systemEvents, "$locationInfo | $_ $userILSInfo";
		}
	}
	else{
		### What should end up in this else-statement, which we don't care about? 
		### Logout events, Login.Failure events, and System startup/shut down events. 
	}
}	

###################################################################
### Identifies Users on the EZProxy Watchlist #####################

### Array that stores the EZProxy audit log event for an event that corresponds to a 
### username from the user watchlist. 
my @identifiedWatchlistUsers  = "\n___User Watchlist___";

### Foreach-loop used to iterate through the IP watchlist of usernames. 
foreach (@watchlist_array) {

	my $watchListUser = lc($_);

	### If-else statement used to allow and ignore comments and blank lines in the user_watchlist.txt file. 
	if (($watchListUser =~ /^#/) || ($watchListUser eq "")) {}
	else {
		### Foreach-loop that iterates thru the EZProxy audit log events. 
		foreach (@audit_log){
		
			my @logEvent = split('\t',$_);
			
			### Grabs just the username for the EZProxy audit log event. 
			my $username = lc(@logEvent[3]);
		
			### This if-statement evaluates to see if the username of an event matches the username from 
			### the watchlist. We don't really care about logout events, because this should catch the 
			### corresponding login event first and there is no need to clutter the output email. 
			if (($username =~ /^$watchListUser$/) && ($_ !~ /Logout/)) {
				my @logEvent = split('\t',$_);
				my $ipAddress = @logEvent[2];
				my $decIP = ip_to_int($ipAddress);
				my $locationInfo = locID_look_up($decIP);

				### Calls subroutine to lookup user in ILS, in this case to identify users with expired library privileges.  
				my $userILSInfo = ILS_lookup($_);
				
				push @identifiedWatchlistUsers, "$locationInfo | @logEvent[0,1,2,3,5] $userILSInfo";
			}
		}
	}
}	

###################################################################
### Identifies IP Addresses on the EZProxy IP Watchlist ###########

### Array that stores the EZProxy audit log event that matches an IP address from the IP address watchlist. 
my @identifiedWatchlistIP  = "\n___IP Address Watchlist___";

### Foreach-loop used to iterate through the IP watchlist. 
foreach (@IP_watchlist_array) {

	my $watchListIP = $_;

	### If-else statement used to allow and ignore comments and blank lines in the ip_watchlist.txt file. 
	if (($watchListIP =~ /^#/) || ($watchListIP eq "")) {}
	else {
		### Foreach-loop that iterates thru the EZProxy audit log events. 
		foreach (@audit_log){
		
			my @logEvent = split('\t',$_);
		
			### Grabs just the IP address for the EZProxy audit log event. 
			my $ipAddress = @logEvent[2];
		
			### This if-statement evaluates to see if the IP address of an event matches the IP address
			### from the watchlist. We don't really care about logout events, because this should catch 
			### the corresponding login event first and there is no need to clutter the output email. 
			if (($ipAddress eq $watchListIP) && ($_ !~ /Logout/)) {
				my $decIP = ip_to_int($ipAddress);
				my $locationInfo = locID_look_up($decIP);
		
				### Calls subroutine to lookup user in ILS, in this case to identify users with 
				### expired library privileges.  
				my $userILSInfo = ILS_lookup($_);
			
				push @identifiedWatchlistIP, "$locationInfo | @logEvent[0,1,2,3,5] $userILSInfo";
			}
		}
	}
	
}	

###################################################################
### Identify Users From Outside Our Country #######################

### This variable is used to store the two character country code for our country. Successfully EZProxy login events 
### from outside this country will be reported in the output email. This country code should match the country code
### that is normally reported in the EZProxy audit website (which is unfortunately not stored in the raw file, but 
### pulled on the fly using the MaxMind IP geo-location files.)
### my $ourCountryCode = "CHANGE_ME";
my $ourCountryCode = "US";

### This array contains the successful logins OR BlockCountryChange events from outside our country. 
my @outsideCountry = "\n___ Successful Logins Outside $ourCountryCode ___";

### This foreach-loop iterates through the EZProxy audit log of events to identify successful login 
### events from outside our country. 
foreach (@audit_log) {

	### Stores the audit log event being evaluated. 
	my $auditEvent = $_;
	
	### Checks to see if the audit log event being evaluated was a successful login OR a  
	### BlockCountryChange event, otherwise moves on to next event/row in the audit log. 
	if (($_ =~ /Login.Success/) or ($_ =~ /BlockCountryChange/)) {
	
		### Splits a successful login event into tab delimited parts. 
		my @logEvent = split('\t',$_);
		
		### Calls subroutine to lookup user in ILS, in this case to identify users with expired library privileges.  
		my $userILSInfo = ILS_lookup($_);
	
		#### Grabs just the IP address for the successful login event. 
		my $successIpAddress = @logEvent[2];	
	
		### Sends the IP address to a subroutine that converts the quad IP address to its integer 
		### value that is used for lookups in GeoLiteCity-Blocks.csv file.
		my $searchIP = ip_to_int($successIpAddress);
			
		### A counter used to grabbing the correct item from various arrays. 
		my $ipCounter = 0;
		
		### This array is used later in this script to identify users with successful logins from disparate locations. 
		### I am being lazy and just grabbing the logEvent in this if-statement for later use. 
		push @successfulUsersEvents, $_;
		
		### This foreach-loop goes through each IP address stored in @covertedIPLower, which 
		### is from the GeoLiteCity-Blocks.csv file. 
		foreach (@covertedIPLower) {
			
			### If-statement that evaluates the successful login event's converted IP address ($searchIP) to 
			### see if it is (1.) greater than or equal to the IP address from the lower converted IP address 
			### ($covertedIPLower[$ipCounter]) of the IP range AND (2.) less than or equal to the upper
			### converted IP address ($covertedIPUpper[$ipCounter]) for the range. 
			if ($searchIP >= $covertedIPLower[$ipCounter] && $searchIP <= $covertedIPUpper[$ipCounter]) {
			
				### A subroutine call to lookup city/state/country info in the array created 
				### from GeoLiteCity-Location.csv.
				my $locationInfo = city_look_up($locId[$ipCounter]);

				### A variable to hold just the country code from the event's location information, 
				### to see if it is outside of our country. Substr is used to grab just the two 
				### character country code. 
				my $countryCode = substr($locationInfo, -2, 2);
					
				### If-statement to evaluate if the event occurred outside our country, and if so 
				### adds the event details to the array @outsideCountry. 
				if ($countryCode ne $ourCountryCode) {	
					push @outsideCountry, "$locationInfo | @logEvent[0,1,2,3,5] $userILSInfo";
				}
		
				### Last is used here to break out of the parent foreach-loop once we have identified that the current 
				### event occurred outside of our country and has been pushed onto the @outsideCountry array. 
				last;
			}	
			$ipCounter++;
		}	
	}
}

########################################################################
### Identify Users with Successful Logins from 2 Different Locations ###

### This array contains successful logins AND BlockCountryChange events that occur from 
### two different geographic locations.
my @dispLocations = "\n___Successful Logins From Disparate Locations (ignores same country/state)___";

### A hash to store a username/ip pair that is used later to identify users that have logged in 
### to EZProxy from different geographic locations. 
my %userIpHash = ();

### Creates a username/IP address hash from the @successfulUsersEvents array. The array 
### @successfulUsersEvents, used in this foreach-loop, is created in a function above to save time/effort. 
foreach (@successfulUsersEvents){
	my @logEvent = split('\t',$_);
	my $successIpAddress = @logEvent[2];
	my $successUserName = uc(@logEvent[3]);

	$userIpHash{ $successUserName } = $successIpAddress;
}

### This foreach-loop goes through the array @successfulUsersEvents, which contains successful 
### logins and BlockCountryChange events.
foreach (@successfulUsersEvents) {
	my @logEvent = split('\t',$_);
	my $ipAddress = @logEvent[2];
	my $userName = uc(@logEvent[3]);
	my $decIP = ip_to_int($ipAddress);
	my $locationInfo = locID_look_up($decIP);
	
	### Calls subroutine to lookup user in ILS, in this case to identify users with expired library privileges. 
	my $userILSInfo = ILS_lookup($_);
	
	### This while-loop goes through the hash userIpHash, so that each username in the hash 
	### can be compared to the successful login event from the foreach-loop above. 
	while ( my ($successUserName, $successIpAddress) = each(%userIpHash) ) {
	
		### If-statement that checks two conditions; 1. if the username from the hash matches the successful
		### login event from the above foreach loop; and 2. if the IP address from the hash DOES NOT match 
		### the IP from the foreach loop. If the if-statement is true, then we don't care about 
		### the event, because the login event is the same as the event from the hash. We only care 
		### if the usernames are the same and the IP is different.  
		if (($userName eq $successUserName) && ($ipAddress ne $successIpAddress)){
			my $tempDecIP = ip_to_int($successIpAddress);
			my $successIpAddressLocation = locID_look_up($tempDecIP);
			
			### This if-statement uses the substr function to evaluate ONLY the country and state 
			### code of the hash and login event. This is so we don't get users that logged in from 
			### different IP addresses, but from within the same city or state. While these might be 
			### important, this if-statement reduces the amount of noise in the email the script creates. 
			if (substr($locationInfo, -6, 6) ne substr($successIpAddressLocation, -6, 6)){
				push @dispLocations, "$successIpAddressLocation | $successIpAddress AND $locationInfo | @logEvent[0,2,3,5] $userILSInfo";
			}
		}
	}
}

###################################################################
### Subroutines ###################################################
###################################################################

###################################################################
### Subroutine: ip_to_int #########################################
### This subroutine is passed an IP address and returns the converted decimal value of 
### that address. This value can be used to lookup the locid for the IP address in GeoLiteCity-Blocks.csv. 
### INPUT: IP address. 
### OUTPUT: The decimal value for the IP address. 	

sub ip_to_int { 
    unpack("N",inet_aton(shift)); 
} 

###################################################################
### Subroutine: city_look_up ######################################
### This subroutine is passed the locID value that was found in GeoLiteCity-Blocks.csv and 
### uses that value to lookup the geoloc information for it in GeoLiteCity-Location.csv
### INPUT: The locID value from the array from GeoLiteCity-Blocks.csv
### OUTPUT: A variable that contains the city, state, and country info from GeoLiteCity-Location.csv

sub city_look_up {

	### Temp variable the holds the locID passed to the subroutine. 
	my $temp_locID = @_[0];
	
	### Counter variable used to grab the necessary elements from the various arrays. 
	my $counter = 0;
	
	if (exists($previousLocIDHash{$temp_locID})) {
		### The locID value (key) has already been searched for, found, and stored in the hash, 
		### pass the location (value) back.
		my $tempLocation = $previousLocIDHash{$temp_locID};
		return $tempLocation;
	} else {
		### Foreach-loop that iterates over the cityLocId array, which contains the locID 
		### values from GeoLiteCity-Location.csv
		foreach (@cityLocId) {
			### If-statement checks to see if the the locID passed to the subroutine is the same locID being 
			### evaluated from @cityLocId. If it is then we have identified the location information we are 
			### looking for and need to return that info to whatever part of the program that called this subroutine. 
		
			if ($cityLocId[$counter] == $temp_locID) {	
				my $tempCity = $city[$counter];
			
				### If the source input file for the array has this element as blank, replace that value with N/A. 
				if ($tempCity eq ""){
					$tempCity = "N/A";
				}
			
			### If the source input file for the array has this element as blank, replace that value with N/A. 
			my $tempRegion = $region[$counter];
			if ($tempRegion eq ""){
				$tempRegion = "N/A";
			}
			
			### If the source input file for the array has this element as blank, replace that value with N/A. 
			### Else if the value of the element is A1, replace that with Anonymous. 
			my $tempCountry = $country[$counter];
			if ($tempCountry eq ""){
				$tempCountry = "N/A";
			}
			elsif ($tempCountry eq "A1"){
				$tempCountry = "Anonymous";
			}
			
			### Temp variable to hold all the location information to be returned to the part of the program 
			### that called this subroutine. 
			my $tempLocINFO = $tempCity.', '.$tempRegion.', '.$tempCountry;
			return $tempLocINFO;
		}
		$counter++;
	}
	}
	
}

###################################################################
### Subroutine: locID_look_up #####################################
### This subroutine is passed the decimal value for an IP address and returns the location information for 
### an IP address. If the IP address is unknown the value "UNKNOWN IP" is returned to be displayed in the email. 
### In reality the unknown IP address is likely an on-campus address, so the end user may wish to update 
### the value of $unknownIP to make more sense in their environment. 
### INPUT: Decimal value for an IP address. 
### OUTPUT: A variable with the location information for the locID, or the value "UNKNOWN IP" 
###			if the IP address is unknown. 

sub locID_look_up {
	my $ipCounter = 0;
	my $tempDecimalIP = @_[0];
		
	### This variable contains the size of the covertedIPLower array, that is used to know when we have 
	### reached the end of the array so we can assume the IP address is unknown. 
	my $arraySize = @covertedIPLower - 1;
	
	### If-statement checks to see if the location info for the address has already been found. If it has,  
	### passes the value of the hash (the iP address's geolocation) back to the function calling this subroutine.
	### Else the subroutine continues and does the geolocation lookup for the IP address. 
	if (exists($previousLookupHash{$tempDecimalIP})) {
		### The IP decimal value (key) for the IP has already been found and stored in the hash, pass the location (value) back.
		my $tempLocation = $previousLookupHash{$tempDecimalIP};
		return $tempLocation;
	} 
	else {
		foreach (@covertedIPLower) {
	
			### If-statement that evaluates the tempDecimalIP for an IP address to see if it is between the lower 
			### and upper ranges of the locID lookup array. If it is between these values, it calls the city_look_up 
			### subroutine to get the actually location information. 
			if ($tempDecimalIP >= $covertedIPLower[$ipCounter] && $tempDecimalIP <= $covertedIPUpper[$ipCounter]) {	
				my $tempLocation = city_look_up($locId[$ipCounter]);
				$previousLookupHash{ $tempDecimalIP } = $tempLocation; 
				return $tempLocation;
			}
		
			### This if-statement is used to identify when the tempDecimalIP was not found in the covertedIPLower array, 
			### likely due to it being an on-campus IP address. The value of unknownIP can be changed to whatever is needed. 
			if ($arraySize == $ipCounter){
				my $unknownIP = "Unknown IP";
				$previousLookupHash{ $tempDecimalIP } = $unknownIP; 
				return $unknownIP;
			}
		
		$ipCounter++;
		}
	}
}

###################################################################
### Subroutine: ILS_lookup ########################################
### This subroutine is passed the log event for a successful login, and returns a value to be displayed in the email. 
### This subroutine is to be used to perform a lookup in an ILS, and can be ignored or customized by a site.  
### In our case, this lookup is to determine whether the user has expired library privileges in our ILS Symphony. 
### If the user has current library privileges a null value is returned and nothing is displayed in the email. 
### INPUT: The log event for a successful login, which must contain the username. 
### OUTPUT: A variable that contains " | Expired User" if the user is expired. A null value is returned if the 
### user has active privileges. 

sub ILS_lookup {
	
	### Splits a successful login event into tab delimited parts. 
	my @logEvent = split('\t',$_);
	
	### Grabs just the username for the successful login event. 
	my $successUsername = @logEvent[3];	

	### This variable is used to store the results of an API call to our ILS. I have removed the code specific 
	### to our ILS. It can be used to grab whatever data from whatever source the end-user sees fit. 
	### This CHANGE_ME only needs updated if a site plans to perform an ILS lookups. Otherwise leave as is. 
	chomp(my $userData = "CHANGE_ME");
	
	### The variable returned from our API call is a string with elements separated by the vertical bar or pipe (|). 
	### This split, on the pipe, puts the the elements into an array, so the individual elements can be acted on. 
	my @userInfo = split('\|',$userData);
	my $expirationDate = @userInfo[4];
	
	### This if-elseif-else statement determines if the user is expired or unknown in our ILS, and if neither 
	### applies returns nothing. Some users have an expirationDate in the future so evaluating the 
	### expirationDate against today's date is also required.  I am leave this code here to be used by other sites 
	### as they see fit, and to illustrate how we use the returns. Since $userData above is essentially defined 
	### as a null value as delivered this script should always return a null value. 
	if (($expirationDate > 0) && ($expirationDate < $yyyymmdd)) {
		### Returns this if the ILS lookup finds the user has expired library privileges. 
		return "| Expired User: $expirationDate";
	}
	elsif ($userData eq "") {
		### Returns this if the ILS lookup returns no user info on the username. 
		return "| Unknown User!";
	}
	else {
		### Returns this if the ILS lookup finds the user has active library privileges. 
		return "";
	}
}

###################################################################
### Outputs and Emails ############################################
###################################################################

### Prints the date to the top of the output file. 
print(OUT "EZProxy audit for $yesterdays_audit_file\n");

### Output Successful Logins From Outside Our Country #############
### This if-statement is used to see if any events were found and pushed onto the array. 
### If not then the value below is added and output to the email. 
if (!@outsideCountry[1]) {
	push @outsideCountry, 'No users successfully logged in from outside our country on '.$yesterdays_audit_file;
}

chomp @outsideCountry;
foreach(@outsideCountry) {
	print(OUT "$_\n\n");
}

### Output Logins from Different Locations ########################
### This if-statement is used to see if any events were found and pushed onto the array. 
### If not then the value below is added and output to the email. 
if (!@dispLocations[1]) {
	push @dispLocations, 'No users successfully logged in from two different locations on '.$yesterdays_audit_file;
}

chomp @dispLocations;
foreach(@dispLocations) {
	print(OUT "$_\n\n");
}

### Output Denied Users ###########################################
### This if-statement is used to see if any events were found and pushed onto the array. 
### If not then the value below is added and output to the email. 
if (!@deniedUsers[1]) {
	push @deniedUsers, 'No users were denied on '.$yesterdays_audit_file;
}

chomp @deniedUsers;
foreach(@deniedUsers) {
	print(OUT "$_\n\n");
}

### Output System Events ##########################################
### This if-statement is used to see if any events were found and pushed onto the array. 
### If not then the value below is added and output to the email. 
if (!@systemEvents[1]) {
	push @systemEvents, "No system events events occurred for $yesterdays_audit_file";
}

chomp @systemEvents;
foreach(@systemEvents) {
	print(OUT "$_\n");
}

### Output Login.Intruder.IP Events ###############################
### This if-statement is used to see if any events were found and pushed onto the array. 
### If not then the value below is added and output to the email. 
if (!@ipIntruders[1]) {
	push @ipIntruders, 'No Login.Intruder.IP events occurred for '.$yesterdays_audit_file;
}

chomp @ipIntruders;
foreach(@ipIntruders) {
	print(OUT "$_\n");
}

### Output Login.Intruder.User Events #############################
### This if-statement is used to see if any events were found and pushed onto the array. 
### If not then the value below is added and output to the email. 
if (!@userIntruders[1]) {
	push @userIntruders, 'No Login.Intruder.User events occurred for '.$yesterdays_audit_file;
}

chomp @userIntruders;
foreach(@userIntruders) {
	print(OUT "$_\n");
}

### Output UsageLimit Events ##################################
### This if-statement is used to see if any events were found and pushed onto the array. 
### If not then the value below is added and output to the email. 
if (!@usageLimitEvents[1]) {
	push @usageLimitEvents, 'No UsageLimit Events occurred for '.$yesterdays_audit_file;
}

chomp @usageLimitEvents;
foreach(@usageLimitEvents) {
	print(OUT "$_\n");
}

### Output Rejected IP Addresses ##################################
### This if-statement is used to see if any events were found and pushed onto the array. 
### If not then the value below is added and output to the email. 
if (!@rejectedIPs[1]) {
	push @rejectedIPs, 'No IP Addresses were rejected for '.$yesterdays_audit_file;
}

chomp @rejectedIPs;
foreach(@rejectedIPs) {
	print(OUT "$_\n");
}

### Output Users Watchlist#########################################
### This if-statement is used to see if any events were found and pushed onto the array. 
### If not then the value below is added and output to the email. 
if (!@identifiedWatchlistUsers[1]) {
	push @identifiedWatchlistUsers, 'No users from the watchlist were active on '.$yesterdays_audit_file;
}

chomp @identifiedWatchlistUsers;
foreach(@identifiedWatchlistUsers) {
	print(OUT "$_\n\n");
}

### Output IP Addresses Watchlist##################################
### This if-statement is used to see if any events were found and pushed onto the array. 
### If not then the value below is added and output to the email. 
if (!@identifiedWatchlistIP[1]) {
	push @identifiedWatchlistIP, 'No IP addresses from the IP watchlist were active on '.$yesterdays_audit_file;
}

chomp @identifiedWatchlistIP;
foreach(@identifiedWatchlistIP) {
	print(OUT "$_\n\n");
}

### Output ILS Lookup Users #######################################
### This if-statement is used to see if any events were found and pushed onto the array. 
### If not then the value below is added and output to the email. 
if (!@reportUser[1]) {
	push @reportUser, 'No Successful logins by expired users for '.$yesterdays_audit_file;
}

chomp @reportUser;
foreach(@reportUser) {
	print(OUT "$_\n\n");
}

close(OUT);

### The next two lines send the email to the email address(es) that are stored in a variable at the top of this script. 
### To stop emails, but continue to let the script generate a text file, comment out the following two lines. 
### The variables for the location of blat and the email text file are set at the top of this script with the email address(es). 
### This script sends a copy of the email as an attachment when this script is invoked at the command line, but not
### when it is invoked as a scheduled task. 
my $blatScript = " \"$blatLocation\" \"$emailTextLocation\" -q -subject \"EZProxy audit for $yesterdays_audit_file\" -to \"$emailAddresses\" -attach \"$emailTextLocation\" ";
system($blatScript);

### Outputs to the screen so we know when the script is complete. Can be commented out when development is complete 
### and the task scheduler is invoking the script. 
print "\n$outfile has been created for $yesterdays_audit_file and an email sent to $emailAddresses.\n";
